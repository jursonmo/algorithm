##### 佛洛依德算法
需求： 指定某个源节点到某个目的节点的路径必须经过某个节点。或者 指定路径不能经过某个节点，

1. 先拿必须经过某个中间节点来举例：
```
      3---7
     /            \
    1---------4----5----2
 ```                
假如， 1到2， 要求必须经过7节点，那么计算路由时，查看1到2的最佳线路上是否有7节点，没就看邻居到2的最佳线路上否经过7节点，1 发现邻居3 到2 包含了7节点的， 所有1到2的路径的下一跳是3节点
但是返回数据是2到1的，如果也要求必须经过3节点，那就比较麻烦了，因为2的邻居只有5，如果5到1的最佳路径没有经过3节点，2只能把下一跳设置5， 但是5如何转发，2是控制不了的，2节点是无能为力的。
同理如果在其他拓扑图里， 1到2时，1的邻居们到2的最短路径也没有经过7，1到2也没法保证数据一定能经过节点7.

这种情况下，只能设置4的转发策略路由：源地址是2的，目的地址是1节点的，转发给7节点，同时7节点也要设置同样的转发策略路由， 这样是特别麻烦的，而且如果以后线路有更新，比如 3到4节点新建一条线路，那么 4节点的转发策略路由就不应该转发给7节点了，而是直接转发给3节点，运维特别困难的，

所以，应该搞一套额外的做法：数据里包含转发路径？即以3为顶点，2到1 的路径最短路径算出来。然后把路径集成在数据流里。dijistra 算法就是单个顶点到目的顶点的最短路径， 也就是2到7的最短路径和7到1的最短路径，就是2到1 经过7节点的最短路径。 其实可以不用把整个路径集成到数据流里，可以有一个临时目的地址和真正目的地址的概念，即临时目的地址是7节点， 真正目的节点是1节点，当7节点看到有虚拟目的节点等于自己，就把数据的真正目的节点地址放在最前面，节点的转发就根据最前面的地址。

如果指定必须经过多个中间节点，那么就有多个虚拟目的节点地址，
[虚拟目的节点地址1，虚拟目的节点地址2，虚拟目的节点地址3........最后一个是真正的目的节点 ]。
如果节点接受到数据时，发现数据里有多个地址，并且第一个虚拟地址跟节点地址一样，那么做pop 出栈操作， 然后根据栈顶地址做转发就行了。

2. 如果指定某个源节点到某个目的节点的路径不能经过某个节点？
